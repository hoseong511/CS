## **2.2.4 비부호형과 부호형 간의 변환**
- C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다. 
- 비부호형을 부호형으로 캐스팅하는 효과는 무엇이 되어야 하겠는가? 라는 질문에 대한 대답은 숫자 관점에서가 아닌 비트수준의 관점에 기초한다.
- 캐스팅 시, 비트 값들은 동일하게 유지하지만 비트를 해석하는 방법은 변경된다는 점.
- *T2U*는 2의 보수형 수에서 이에 대응하는 비부호형 값으로, *U2T*가 이와 반대 방향으로 변환한다는 것
- 2의 보수에서 비부호형으로 변환
  $$ T2U_w(x) = \begin{cases}x + 2^w,\; x < 0 \\x,\; x \geq 0\end{cases} $$
- 비부호형에서 2의 보수형으로 변환 
  $$ 0 \leq u \leq UMax_w $$

  $$ U2T_w(u) = \begin{cases}u ,\; u \leq TMax_w \\u - 2^w,\; u > TMax_w \end{cases} $$

## **2.2.5 C에서 부호형과 비부호형 비교**
- 명시적, 묵시적 변환
  - 명시적인 캐스팅
	```c
	int	tx, ty;
	unsigned ux, uy;
	
	tx = (int) ux;
	uy = (unsigned) ty;
	```
  - 묵시적으로 변환
	```c
	int	tx, ty;
	unsigned ux, uy;
	tx = ux;
	uy = ty;
	```
- C에서 비부호형과 부호형 값들이 섞여 있는 수식을 처리하는 방식은 직관적이지 않은 동작이 발생된다.
  - 한 개의 피연산자가 부호형이고, 다른 것이 비부호형인 경우 C는 묵시적으로 비부호형으로 변환 
  - -1 < 0U 비교문, 두 번째 피연산자가 비부호형이므로 첫 번째 피연산자는 묵시적으로 비부호형으로 변환

## **2.2.6 수의 비트 표시를 확장**
- 값은 동일하게 유지한 채 다른 길이의 워드로 정수를 변환하는 것은 일반적인 연산의 하나.
- 비부호형 수를 보다 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가함. 이 연산은 ***영의 확장 zero extension***이다.
- 비부호형 수를 영의 확장으로 확대
- 2의 보수를 ***부호 확장 sign extension***으로 확대
- 한 데이터 길이에서 다른 길이로 변환하는 작업과 비부호형과 부호형 사이에 변환하는 작업 간 순서가 프로그램 동작에 영향을 줄 수 있다는 점이다.
  ```c
  short	sx = -12345;
  unsigned	uy = sx;

  printf("uy = %u: \t", uy);
  show_bytes((byte_pointer) &uy, sizeof(unsigned));
  ```
- short에서 unsigned 로 변환할 때, 프로그램이 먼저 자료형 크기를 바꾸고 다음에 자료형(부호형 -> 비부호형)을 바꾼다는 것을 보여줌.

## **2.2.7 숫자의 절삭**
  ```c
  int	x = 53191;
  short	sx = (short) x;
  int	y = sx;
  ```
  - x를 short로 타입 변환 때 32비트 int를 16비트 short로 절삭함.
  - 이것은 일종의 오버플로우와 같다.
- 비부호형 숫자의 절삭
  - mod 처리
- 2의 보수 숫자의 절삭
  - 비부호형으로 바꾼 후, mod처리








